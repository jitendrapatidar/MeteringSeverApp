{"ast":null,"code":"import React, { forwardRef, useState, useRef, useMemo, useLayoutEffect, useEffect, useImperativeHandle, useCallback, createElement } from 'react';\nimport EventBus from './EventBus';\nimport InteractionMasks from './masks/InteractionMasks';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport SummaryRow from './SummaryRow';\nimport { ValueFormatter } from './formatters';\nimport { assertIsValidKey, getColumnMetrics, getColumnScrollPosition, getHorizontalRangeToRender, getScrollbarSize, getVerticalRangeToRender, getViewportColumns } from './utils';\nimport { CellNavigationMode } from './common/enums';\n/**\r\n * Main API Component to render a data grid of rows and columns\r\n *\r\n * @example\r\n *\r\n * <DataGrid columns={columns} rows={rows} />\r\n*/\n\nfunction DataGrid({\n  // Grid and data Props\n  columns: rawColumns,\n  rows,\n  summaryRows,\n  rowKey,\n  onRowsUpdate,\n  // Dimensions props\n  width,\n  height = 350,\n  minColumnWidth = 80,\n  rowHeight = 35,\n  headerRowHeight = rowHeight,\n  headerFiltersHeight = 45,\n  // Feature props\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumn,\n  sortDirection,\n  onSort,\n  filters,\n  onFiltersChange,\n  // Custom renderers\n  defaultFormatter = ValueFormatter,\n  rowRenderer: RowRenderer = Row,\n  emptyRowsRenderer,\n  // Event props\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onCheckCellIsEditable,\n  // Toggles and modes\n  enableFilters = false,\n  enableCellAutoFocus = true,\n  enableCellCopyPaste = false,\n  enableCellDragAndDrop = false,\n  cellNavigationMode = CellNavigationMode.NONE,\n  // Miscellaneous\n  editorPortalTarget = document.body\n}, ref) {\n  var _a;\n  /**\r\n   * refs\r\n   * */\n\n\n  const gridRef = useRef(null);\n  const lastSelectedRowIdx = useRef(-1);\n  /**\r\n   * states\r\n   */\n\n  const [eventBus] = useState(() => new EventBus());\n  const [gridWidth, setGridWidth] = useState(0);\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState(() => new Map());\n  /**\r\n   * computed values\r\n   */\n\n  const viewportWidth = (width || gridWidth) - 2; // 2 for border width;\n\n  const {\n    columns,\n    lastFrozenColumnIndex,\n    totalColumnWidth\n  } = useMemo(() => {\n    return getColumnMetrics({\n      columns: rawColumns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultFormatter\n    });\n  }, [columnWidths, rawColumns, defaultFormatter, minColumnWidth, viewportWidth]);\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo(() => {\n    return getHorizontalRangeToRender(columns, lastFrozenColumnIndex, viewportWidth, scrollLeft);\n  }, [scrollLeft, columns, lastFrozenColumnIndex, viewportWidth]);\n  const viewportColumns = useMemo(() => {\n    return getViewportColumns(columns, colOverscanStartIdx, colOverscanEndIdx);\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n  const totalHeaderHeight = headerRowHeight + (enableFilters ? headerFiltersHeight : 0);\n  const clientHeight = height - 2 // border width\n  - totalHeaderHeight - ((_a = summaryRows === null || summaryRows === void 0 ? void 0 : summaryRows.length) !== null && _a !== void 0 ? _a : 0) * rowHeight - (totalColumnWidth > viewportWidth ? getScrollbarSize() : 0);\n  const [rowOverscanStartIdx, rowOverscanEndIdx] = getVerticalRangeToRender(clientHeight, rowHeight, scrollTop, rows.length);\n  /**\r\n   * effects\r\n   */\n\n  useLayoutEffect(() => {\n    // Do not calculate the width if width is provided\n    if (typeof width === 'number') return;\n\n    function onResize() {\n      // Immediately re-render when the component is mounted to get valid columnMetrics.\n      setGridWidth(gridRef.current.getBoundingClientRect().width);\n    }\n\n    onResize();\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [width]);\n  useEffect(() => {\n    if (!onSelectedRowsChange) return;\n\n    const handleRowSelectionChange = ({\n      rowIdx,\n      checked,\n      isShiftClick\n    }) => {\n      assertIsValidKey(rowKey);\n      const newSelectedRows = new Set(selectedRows);\n      const rowId = rows[rowIdx][rowKey];\n\n      if (checked) {\n        newSelectedRows.add(rowId);\n        const previousRowIdx = lastSelectedRowIdx.current;\n        lastSelectedRowIdx.current = rowIdx;\n\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n          const step = Math.sign(rowIdx - previousRowIdx);\n\n          for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n            newSelectedRows.add(rows[i][rowKey]);\n          }\n        }\n      } else {\n        newSelectedRows.delete(rowId);\n        lastSelectedRowIdx.current = -1;\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n    };\n\n    return eventBus.subscribe('SELECT_ROW', handleRowSelectionChange);\n  }, [eventBus, onSelectedRowsChange, rows, rowKey, selectedRows]);\n  useImperativeHandle(ref, () => ({\n    scrollToColumn(idx) {\n      scrollToCell({\n        idx\n      });\n    },\n\n    scrollToRow(rowIdx) {\n      const {\n        current\n      } = gridRef;\n      if (!current) return;\n      current.scrollTop = rowIdx * rowHeight;\n    },\n\n    selectCell(position, openEditor) {\n      eventBus.dispatch('SELECT_CELL', position, openEditor);\n    }\n\n  }));\n  /**\r\n   * event handlers\r\n   */\n\n  function onGridScroll(event) {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);\n  }\n\n  const handleColumnResize = useCallback((column, width) => {\n    const newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n    onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n\n  function handleRowsUpdate(event) {\n    onRowsUpdate === null || onRowsUpdate === void 0 ? void 0 : onRowsUpdate(event);\n  }\n  /**\r\n   * utils\r\n   */\n\n\n  function getFrozenColumnsWidth() {\n    if (lastFrozenColumnIndex === -1) return 0;\n    const lastFrozenCol = columns[lastFrozenColumnIndex];\n    return lastFrozenCol.left + lastFrozenCol.width;\n  }\n\n  function scrollToCell({\n    idx,\n    rowIdx\n  }) {\n    const {\n      current\n    } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const {\n        clientWidth\n      } = current;\n      const {\n        left,\n        width\n      } = columns[idx];\n      const isCellAtLeftBoundary = left < scrollLeft + width + getFrozenColumnsWidth();\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        const newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getViewportRows() {\n    var _a;\n\n    const rowElements = [];\n\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      let key = rowIdx;\n      let isRowSelected = false;\n\n      if (rowKey !== undefined) {\n        const rowId = row[rowKey];\n        isRowSelected = (_a = selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.has(rowId)) !== null && _a !== void 0 ? _a : false;\n\n        if (typeof rowId === 'string' || typeof rowId === 'number') {\n          key = rowId;\n        }\n      }\n\n      rowElements.push(React.createElement(RowRenderer, {\n        key: key,\n        rowIdx: rowIdx,\n        row: row,\n        viewportColumns: viewportColumns,\n        lastFrozenColumnIndex: lastFrozenColumnIndex,\n        eventBus: eventBus,\n        isRowSelected: isRowSelected,\n        onRowClick: onRowClick\n      }));\n    }\n\n    return rowElements;\n  }\n\n  return React.createElement(\"div\", {\n    className: \"rdg\",\n    style: {\n      width,\n      height,\n      '--header-row-height': `${headerRowHeight}px`,\n      '--filter-row-height': `${headerFiltersHeight}px`,\n      '--row-width': `${totalColumnWidth}px`,\n      '--row-height': `${rowHeight}px`\n    },\n    ref: gridRef,\n    onScroll: onGridScroll\n  }, React.createElement(HeaderRow, {\n    rowKey: rowKey,\n    rows: rows,\n    columns: viewportColumns,\n    onColumnResize: handleColumnResize,\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    allRowsSelected: (selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.size) === rows.length,\n    onSelectedRowsChange: onSelectedRowsChange,\n    sortColumn: sortColumn,\n    sortDirection: sortDirection,\n    onSort: onSort\n  }), enableFilters && React.createElement(FilterRow, {\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    columns: viewportColumns,\n    filters: filters,\n    onFiltersChange: onFiltersChange\n  }), rows.length === 0 && emptyRowsRenderer ? createElement(emptyRowsRenderer) : React.createElement(React.Fragment, null, viewportWidth > 0 && React.createElement(InteractionMasks, {\n    rows: rows,\n    rowHeight: rowHeight,\n    columns: columns,\n    enableCellAutoFocus: enableCellAutoFocus,\n    enableCellCopyPaste: enableCellCopyPaste,\n    enableCellDragAndDrop: enableCellDragAndDrop,\n    cellNavigationMode: cellNavigationMode,\n    eventBus: eventBus,\n    gridRef: gridRef,\n    totalHeaderHeight: totalHeaderHeight,\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop,\n    scrollToCell: scrollToCell,\n    editorPortalTarget: editorPortalTarget,\n    onCheckCellIsEditable: onCheckCellIsEditable,\n    onRowsUpdate: handleRowsUpdate,\n    onSelectedCellChange: onSelectedCellChange\n  }), React.createElement(\"div\", {\n    style: {\n      height: rowOverscanStartIdx * rowHeight\n    }\n  }), getViewportRows(), React.createElement(\"div\", {\n    style: {\n      height: (rows.length - 1 - rowOverscanEndIdx) * rowHeight\n    }\n  }), summaryRows === null || summaryRows === void 0 ? void 0 : summaryRows.map((row, rowIdx) => React.createElement(SummaryRow, {\n    key: rowIdx,\n    rowIdx: rowIdx,\n    row: row,\n    bottom: rowHeight * (summaryRows.length - 1 - rowIdx),\n    viewportColumns: viewportColumns,\n    lastFrozenColumnIndex: lastFrozenColumnIndex\n  }))));\n}\n\nexport default forwardRef(DataGrid);","map":{"version":3,"sources":["../src/DataGrid.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAP,IACE,UADF,EAEE,QAFF,EAGE,MAHF,EAIE,OAJF,EAKE,eALF,EAME,SANF,EAOE,mBAPF,EAQE,WARF,EASE,aATF,QAUO,OAVP;AAYA,OAAO,QAAP,MAAqB,YAArB;AACA,OAAO,gBAAP,MAA6B,0BAA7B;AACA,OAAO,SAAP,MAAsB,aAAtB;AACA,OAAO,SAAP,MAAsB,aAAtB;AACA,OAAO,GAAP,MAAgB,OAAhB;AACA,OAAO,UAAP,MAAuB,cAAvB;AACA,SAAS,cAAT,QAA+B,cAA/B;AACA,SACE,gBADF,EAEE,gBAFF,EAGE,uBAHF,EAIE,0BAJF,EAKE,gBALF,EAME,wBANF,EAOE,kBAPF,QAQO,SARP;AAqBA,SAAS,kBAAT,QAAkD,gBAAlD;AAwGA;;;;;;;;AAOA,SAAS,QAAT,CAA4C;AAC1C;AACA,EAAA,OAAO,EAAE,UAFiC;AAG1C,EAAA,IAH0C;AAI1C,EAAA,WAJ0C;AAK1C,EAAA,MAL0C;AAM1C,EAAA,YAN0C;AAO1C;AACA,EAAA,KAR0C;AAS1C,EAAA,MAAM,GAAG,GATiC;AAU1C,EAAA,cAAc,GAAG,EAVyB;AAW1C,EAAA,SAAS,GAAG,EAX8B;AAY1C,EAAA,eAAe,GAAG,SAZwB;AAa1C,EAAA,mBAAmB,GAAG,EAboB;AAc1C;AACA,EAAA,YAf0C;AAgB1C,EAAA,oBAhB0C;AAiB1C,EAAA,UAjB0C;AAkB1C,EAAA,aAlB0C;AAmB1C,EAAA,MAnB0C;AAoB1C,EAAA,OApB0C;AAqB1C,EAAA,eArB0C;AAsB1C;AACA,EAAA,gBAAgB,GAAG,cAvBuB;AAwB1C,EAAA,WAAW,EAAE,WAAW,GAAG,GAxBe;AAyB1C,EAAA,iBAzB0C;AA0B1C;AACA,EAAA,UA3B0C;AA4B1C,EAAA,QA5B0C;AA6B1C,EAAA,cA7B0C;AA8B1C,EAAA,oBA9B0C;AA+B1C,EAAA,qBA/B0C;AAgC1C;AACA,EAAA,aAAa,GAAG,KAjC0B;AAkC1C,EAAA,mBAAmB,GAAG,IAlCoB;AAmC1C,EAAA,mBAAmB,GAAG,KAnCoB;AAoC1C,EAAA,qBAAqB,GAAG,KApCkB;AAqC1C,EAAA,kBAAkB,GAAG,kBAAkB,CAAC,IArCE;AAsC1C;AACA,EAAA,kBAAkB,GAAG,QAAQ,CAAC;AAvCY,CAA5C,EAwC4B,GAxC5B,EAwC0D;;AACxD;;;;;AAGA,QAAM,OAAO,GAAG,MAAM,CAAiB,IAAjB,CAAtB;AACA,QAAM,kBAAkB,GAAG,MAAM,CAAC,CAAC,CAAF,CAAjC;AAEA;;;;AAGA,QAAM,CAAC,QAAD,IAAa,QAAQ,CAAC,MAAM,IAAI,QAAJ,EAAP,CAA3B;AACA,QAAM,CAAC,SAAD,EAAY,YAAZ,IAA4B,QAAQ,CAAC,CAAD,CAA1C;AACA,QAAM,CAAC,SAAD,EAAY,YAAZ,IAA4B,QAAQ,CAAC,CAAD,CAA1C;AACA,QAAM,CAAC,UAAD,EAAa,aAAb,IAA8B,QAAQ,CAAC,CAAD,CAA5C;AACA,QAAM,CAAC,YAAD,EAAe,eAAf,IAAkC,QAAQ,CAA8B,MAAM,IAAI,GAAJ,EAApC,CAAhD;AAEA;;;;AAGA,QAAM,aAAa,GAAG,CAAC,KAAK,IAAI,SAAV,IAAuB,CAA7C,CAnBwD,CAmBR;;AAEhD,QAAM;AAAE,IAAA,OAAF;AAAW,IAAA,qBAAX;AAAkC,IAAA;AAAlC,MAAuD,OAAO,CAAC,MAAK;AACxE,WAAO,gBAAgB,CAAQ;AAC7B,MAAA,OAAO,EAAE,UADoB;AAE7B,MAAA,cAF6B;AAG7B,MAAA,aAH6B;AAI7B,MAAA,YAJ6B;AAK7B,MAAA;AAL6B,KAAR,CAAvB;AAOD,GARmE,EAQjE,CAAC,YAAD,EAAe,UAAf,EAA2B,gBAA3B,EAA6C,cAA7C,EAA6D,aAA7D,CARiE,CAApE;AAUA,QAAM,CAAC,mBAAD,EAAsB,iBAAtB,IAA2C,OAAO,CAAC,MAAuB;AAC9E,WAAO,0BAA0B,CAC/B,OAD+B,EAE/B,qBAF+B,EAG/B,aAH+B,EAI/B,UAJ+B,CAAjC;AAMD,GAPuD,EAOrD,CAAC,UAAD,EAAa,OAAb,EAAsB,qBAAtB,EAA6C,aAA7C,CAPqD,CAAxD;AASA,QAAM,eAAe,GAAG,OAAO,CAAC,MAAyC;AACvE,WAAO,kBAAkB,CACvB,OADuB,EAEvB,mBAFuB,EAGvB,iBAHuB,CAAzB;AAKD,GAN8B,EAM5B,CAAC,iBAAD,EAAoB,mBAApB,EAAyC,OAAzC,CAN4B,CAA/B;AAQA,QAAM,iBAAiB,GAAG,eAAe,IAAI,aAAa,GAAG,mBAAH,GAAyB,CAA1C,CAAzC;AACA,QAAM,YAAY,GAAG,MAAM,GACvB,CADiB,CACf;AADe,IAEjB,iBAFiB,GAGjB,CAAA,CAAA,EAAA,GAAC,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,MAAd,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,EAApB,GAAwB,CAAxB,IAA6B,SAHZ,IAIhB,gBAAgB,GAAG,aAAnB,GAAmC,gBAAgB,EAAnD,GAAwD,CAJxC,CAArB;AAMA,QAAM,CAAC,mBAAD,EAAsB,iBAAtB,IAA2C,wBAAwB,CACvE,YADuE,EAEvE,SAFuE,EAGvE,SAHuE,EAIvE,IAAI,CAAC,MAJkE,CAAzE;AAOA;;;;AAGA,EAAA,eAAe,CAAC,MAAK;AACnB;AACA,QAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;;AAC/B,aAAS,QAAT,GAAiB;AACf;AACA,MAAA,YAAY,CAAC,OAAO,CAAC,OAAR,CAAiB,qBAAjB,GAAyC,KAA1C,CAAZ;AACD;;AACD,IAAA,QAAQ;AAER,IAAA,MAAM,CAAC,gBAAP,CAAwB,QAAxB,EAAkC,QAAlC;AACA,WAAO,MAAK;AACV,MAAA,MAAM,CAAC,mBAAP,CAA2B,QAA3B,EAAqC,QAArC;AACD,KAFD;AAGD,GAbc,EAaZ,CAAC,KAAD,CAbY,CAAf;AAeA,EAAA,SAAS,CAAC,MAAK;AACb,QAAI,CAAC,oBAAL,EAA2B;;AAE3B,UAAM,wBAAwB,GAAG,CAAC;AAAE,MAAA,MAAF;AAAU,MAAA,OAAV;AAAmB,MAAA;AAAnB,KAAD,KAAsD;AACrF,MAAA,gBAAgB,CAAC,MAAD,CAAhB;AACA,YAAM,eAAe,GAAG,IAAI,GAAJ,CAAQ,YAAR,CAAxB;AACA,YAAM,KAAK,GAAG,IAAI,CAAC,MAAD,CAAJ,CAAa,MAAb,CAAd;;AAEA,UAAI,OAAJ,EAAa;AACX,QAAA,eAAe,CAAC,GAAhB,CAAoB,KAApB;AACA,cAAM,cAAc,GAAG,kBAAkB,CAAC,OAA1C;AACA,QAAA,kBAAkB,CAAC,OAAnB,GAA6B,MAA7B;;AACA,YAAI,YAAY,IAAI,cAAc,KAAK,CAAC,CAApC,IAAyC,cAAc,KAAK,MAAhE,EAAwE;AACtE,gBAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,GAAG,cAAnB,CAAb;;AACA,eAAK,IAAI,CAAC,GAAG,cAAc,GAAG,IAA9B,EAAoC,CAAC,KAAK,MAA1C,EAAkD,CAAC,IAAI,IAAvD,EAA6D;AAC3D,YAAA,eAAe,CAAC,GAAhB,CAAoB,IAAI,CAAC,CAAD,CAAJ,CAAQ,MAAR,CAApB;AACD;AACF;AACF,OAVD,MAUO;AACL,QAAA,eAAe,CAAC,MAAhB,CAAuB,KAAvB;AACA,QAAA,kBAAkB,CAAC,OAAnB,GAA6B,CAAC,CAA9B;AACD;;AAED,MAAA,oBAAoB,CAAC,eAAD,CAApB;AACD,KArBD;;AAuBA,WAAO,QAAQ,CAAC,SAAT,CAAmB,YAAnB,EAAiC,wBAAjC,CAAP;AACD,GA3BQ,EA2BN,CAAC,QAAD,EAAW,oBAAX,EAAiC,IAAjC,EAAuC,MAAvC,EAA+C,YAA/C,CA3BM,CAAT;AA6BA,EAAA,mBAAmB,CAAC,GAAD,EAAM,OAAO;AAC9B,IAAA,cAAc,CAAC,GAAD,EAAY;AACxB,MAAA,YAAY,CAAC;AAAE,QAAA;AAAF,OAAD,CAAZ;AACD,KAH6B;;AAI9B,IAAA,WAAW,CAAC,MAAD,EAAe;AACxB,YAAM;AAAE,QAAA;AAAF,UAAc,OAApB;AACA,UAAI,CAAC,OAAL,EAAc;AACd,MAAA,OAAO,CAAC,SAAR,GAAoB,MAAM,GAAG,SAA7B;AACD,KAR6B;;AAS9B,IAAA,UAAU,CAAC,QAAD,EAAqB,UAArB,EAAyC;AACjD,MAAA,QAAQ,CAAC,QAAT,CAAkB,aAAlB,EAAiC,QAAjC,EAA2C,UAA3C;AACD;;AAX6B,GAAP,CAAN,CAAnB;AAcA;;;;AAGA,WAAS,YAAT,CAAsB,KAAtB,EAA0D;AACxD,UAAM;AAAE,MAAA,SAAF;AAAa,MAAA;AAAb,QAA4B,KAAK,CAAC,aAAxC;AACA,IAAA,YAAY,CAAC,SAAD,CAAZ;AACA,IAAA,aAAa,CAAC,UAAD,CAAb;AACA,IAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAG,KAAH,CAAR;AACD;;AAED,QAAM,kBAAkB,GAAG,WAAW,CAAC,CAAC,MAAD,EAAkC,KAAlC,KAAmD;AACxF,UAAM,eAAe,GAAG,IAAI,GAAJ,CAAQ,YAAR,CAAxB;AACA,IAAA,eAAe,CAAC,GAAhB,CAAoB,MAAM,CAAC,GAA3B,EAAgC,KAAhC;AACA,IAAA,eAAe,CAAC,eAAD,CAAf;AAEA,IAAA,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAG,MAAM,CAAC,GAAV,EAAe,KAAf,CAAd;AACD,GANqC,EAMnC,CAAC,YAAD,EAAe,cAAf,CANmC,CAAtC;;AAQA,WAAS,gBAAT,CAA0B,KAA1B,EAAgD;AAC9C,IAAA,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAG,KAAH,CAAZ;AACD;AAED;;;;;AAGA,WAAS,qBAAT,GAA8B;AAC5B,QAAI,qBAAqB,KAAK,CAAC,CAA/B,EAAkC,OAAO,CAAP;AAClC,UAAM,aAAa,GAAG,OAAO,CAAC,qBAAD,CAA7B;AACA,WAAO,aAAa,CAAC,IAAd,GAAqB,aAAa,CAAC,KAA1C;AACD;;AAED,WAAS,YAAT,CAAsB;AAAE,IAAA,GAAF;AAAO,IAAA;AAAP,GAAtB,EAAwD;AACtD,UAAM;AAAE,MAAA;AAAF,QAAc,OAApB;AACA,QAAI,CAAC,OAAL,EAAc;;AAEd,QAAI,OAAO,GAAP,KAAe,QAAf,IAA2B,GAAG,GAAG,qBAArC,EAA4D;AAC1D,YAAM;AAAE,QAAA;AAAF,UAAkB,OAAxB;AACA,YAAM;AAAE,QAAA,IAAF;AAAQ,QAAA;AAAR,UAAkB,OAAO,CAAC,GAAD,CAA/B;AACA,YAAM,oBAAoB,GAAG,IAAI,GAAG,UAAU,GAAG,KAAb,GAAqB,qBAAqB,EAA9E;AACA,YAAM,qBAAqB,GAAG,IAAI,GAAG,KAAP,GAAe,WAAW,GAAG,UAA3D;;AACA,UAAI,oBAAoB,IAAI,qBAA5B,EAAmD;AACjD,cAAM,aAAa,GAAG,uBAAuB,CAAC,OAAD,EAAU,GAAV,EAAe,UAAf,EAA2B,WAA3B,CAA7C;AACA,QAAA,OAAO,CAAC,UAAR,GAAqB,UAAU,GAAG,aAAlC;AACD;AACF;;AAED,QAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAI,MAAM,GAAG,SAAT,GAAqB,SAAzB,EAAoC;AAClC;AACA,QAAA,OAAO,CAAC,SAAR,GAAoB,MAAM,GAAG,SAA7B;AACD,OAHD,MAGO,IAAI,CAAC,MAAM,GAAG,CAAV,IAAe,SAAf,GAA2B,SAAS,GAAG,YAA3C,EAAyD;AAC9D;AACA,QAAA,OAAO,CAAC,SAAR,GAAoB,CAAC,MAAM,GAAG,CAAV,IAAe,SAAf,GAA2B,YAA/C;AACD;AACF;AACF;;AAED,WAAS,eAAT,GAAwB;;;AACtB,UAAM,WAAW,GAAG,EAApB;;AAEA,SAAK,IAAI,MAAM,GAAG,mBAAlB,EAAuC,MAAM,IAAI,iBAAjD,EAAoE,MAAM,EAA1E,EAA8E;AAC5E,YAAM,GAAG,GAAG,IAAI,CAAC,MAAD,CAAhB;AACA,UAAI,GAAG,GAAoB,MAA3B;AACA,UAAI,aAAa,GAAG,KAApB;;AACA,UAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,cAAM,KAAK,GAAG,GAAG,CAAC,MAAD,CAAjB;AACA,QAAA,aAAa,GAAA,CAAA,EAAA,GAAG,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAE,GAAd,CAAkB,KAAlB,CAAH,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA+B,KAA5C;;AACA,YAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,OAAO,KAAP,KAAiB,QAAlD,EAA4D;AAC1D,UAAA,GAAG,GAAG,KAAN;AACD;AACF;;AAED,MAAA,WAAW,CAAC,IAAZ,CACE,KAAA,CAAA,aAAA,CAAC,WAAD,EAAY;AACV,QAAA,GAAG,EAAE,GADK;AAEV,QAAA,MAAM,EAAE,MAFE;AAGV,QAAA,GAAG,EAAE,GAHK;AAIV,QAAA,eAAe,EAAE,eAJP;AAKV,QAAA,qBAAqB,EAAE,qBALb;AAMV,QAAA,QAAQ,EAAE,QANA;AAOV,QAAA,aAAa,EAAE,aAPL;AAQV,QAAA,UAAU,EAAE;AARF,OAAZ,CADF;AAYD;;AAED,WAAO,WAAP;AACD;;AAED,SACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AACE,IAAA,SAAS,EAAC,KADZ;AAEE,IAAA,KAAK,EAAE;AACL,MAAA,KADK;AAEL,MAAA,MAFK;AAGL,6BAAuB,GAAG,eAAe,IAHpC;AAIL,6BAAuB,GAAG,mBAAmB,IAJxC;AAKL,qBAAe,GAAG,gBAAgB,IAL7B;AAML,sBAAgB,GAAG,SAAS;AANvB,KAFT;AAUE,IAAA,GAAG,EAAE,OAVP;AAWE,IAAA,QAAQ,EAAE;AAXZ,GAAA,EAaE,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU;AACR,IAAA,MAAM,EAAE,MADA;AAER,IAAA,IAAI,EAAE,IAFE;AAGR,IAAA,OAAO,EAAE,eAHD;AAIR,IAAA,cAAc,EAAE,kBAJR;AAKR,IAAA,qBAAqB,EAAE,qBALf;AAMR,IAAA,eAAe,EAAE,CAAA,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAE,IAAd,MAAuB,IAAI,CAAC,MANrC;AAOR,IAAA,oBAAoB,EAAE,oBAPd;AAQR,IAAA,UAAU,EAAE,UARJ;AASR,IAAA,aAAa,EAAE,aATP;AAUR,IAAA,MAAM,EAAE;AAVA,GAAV,CAbF,EAyBG,aAAa,IACZ,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU;AACR,IAAA,qBAAqB,EAAE,qBADf;AAER,IAAA,OAAO,EAAE,eAFD;AAGR,IAAA,OAAO,EAAE,OAHD;AAIR,IAAA,eAAe,EAAE;AAJT,GAAV,CA1BJ,EAiCG,IAAI,CAAC,MAAL,KAAgB,CAAhB,IAAqB,iBAArB,GAAyC,aAAa,CAAC,iBAAD,CAAtD,GACC,KAAA,CAAA,aAAA,CAAA,KAAA,CAAA,QAAA,EAAA,IAAA,EACG,aAAa,GAAG,CAAhB,IACC,KAAA,CAAA,aAAA,CAAC,gBAAD,EAAiB;AACf,IAAA,IAAI,EAAE,IADS;AAEf,IAAA,SAAS,EAAE,SAFI;AAGf,IAAA,OAAO,EAAE,OAHM;AAIf,IAAA,mBAAmB,EAAE,mBAJN;AAKf,IAAA,mBAAmB,EAAE,mBALN;AAMf,IAAA,qBAAqB,EAAE,qBANR;AAOf,IAAA,kBAAkB,EAAE,kBAPL;AAQf,IAAA,QAAQ,EAAE,QARK;AASf,IAAA,OAAO,EAAE,OATM;AAUf,IAAA,iBAAiB,EAAE,iBAVJ;AAWf,IAAA,UAAU,EAAE,UAXG;AAYf,IAAA,SAAS,EAAE,SAZI;AAaf,IAAA,YAAY,EAAE,YAbC;AAcf,IAAA,kBAAkB,EAAE,kBAdL;AAef,IAAA,qBAAqB,EAAE,qBAfR;AAgBf,IAAA,YAAY,EAAE,gBAhBC;AAiBf,IAAA,oBAAoB,EAAE;AAjBP,GAAjB,CAFJ,EAsBE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,IAAA,KAAK,EAAE;AAAE,MAAA,MAAM,EAAE,mBAAmB,GAAG;AAAhC;AAAZ,GAAA,CAtBF,EAuBG,eAAe,EAvBlB,EAwBE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,IAAA,KAAK,EAAE;AAAE,MAAA,MAAM,EAAE,CAAC,IAAI,CAAC,MAAL,GAAc,CAAd,GAAkB,iBAAnB,IAAwC;AAAlD;AAAZ,GAAA,CAxBF,EAyBG,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,GAAb,CAAiB,CAAC,GAAD,EAAM,MAAN,KAChB,KAAA,CAAA,aAAA,CAAC,UAAD,EAAW;AACT,IAAA,GAAG,EAAE,MADI;AAET,IAAA,MAAM,EAAE,MAFC;AAGT,IAAA,GAAG,EAAE,GAHI;AAIT,IAAA,MAAM,EAAE,SAAS,IAAI,WAAW,CAAC,MAAZ,GAAqB,CAArB,GAAyB,MAA7B,CAJR;AAKT,IAAA,eAAe,EAAE,eALR;AAMT,IAAA,qBAAqB,EAAE;AANd,GAAX,CADD,CAzBH,CAlCJ,CADF;AA0ED;;AAED,eAAe,UAAU,CACvB,QADuB,CAAzB","sourcesContent":["import React, {\n  forwardRef,\n  useState,\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  useImperativeHandle,\n  useCallback,\n  createElement\n} from 'react';\n\nimport EventBus from './EventBus';\nimport InteractionMasks from './masks/InteractionMasks';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport SummaryRow from './SummaryRow';\nimport { ValueFormatter } from './formatters';\nimport {\n  assertIsValidKey,\n  getColumnMetrics,\n  getColumnScrollPosition,\n  getHorizontalRangeToRender,\n  getScrollbarSize,\n  getVerticalRangeToRender,\n  getViewportColumns\n} from './utils';\n\nimport {\n  CalculatedColumn,\n  CheckCellIsEditableEvent,\n  Column,\n  Filters,\n  FormatterProps,\n  Position,\n  RowRendererProps,\n  RowsUpdateEvent,\n  SelectRowEvent\n} from './common/types';\nimport { CellNavigationMode, SortDirection } from './common/enums';\n\nexport interface DataGridHandle {\n  scrollToColumn: (colIdx: number) => void;\n  scrollToRow: (rowIdx: number) => void;\n  selectCell: (position: Position, openEditor?: boolean) => void;\n}\n\nexport interface DataGridProps<R, K extends keyof R, SR = unknown> {\n  /**\n   * Grid and data Props\n   */\n  /** An array of objects representing each column on the grid */\n  columns: readonly Column<R, SR>[];\n  /** A function called for each rendered row that should return a plain key/value pair object */\n  rows: readonly R[];\n  /**\n   * Rows to be pinned at the bottom of the rows view for summary, the vertical scroll bar will not scroll these rows.\n   * Bottom horizontal scroll bar can move the row left / right. Or a customized row renderer can be used to disabled the scrolling support.\n   */\n  summaryRows?: readonly SR[];\n  /** The primary key property of each row */\n  rowKey?: K;\n  /**\n   * Callback called whenever row data is updated\n   * When editing is enabled, this callback will be called for the following scenarios\n   * 1. Using the supplied editor of the column. The default editor is the SimpleTextEditor.\n   * 2. Copy/pasting the value from one cell to another <kbd>CTRL</kbd>+<kbd>C</kbd>, <kbd>CTRL</kbd>+<kbd>V</kbd>\n   * 3. Update multiple cells by dragging the fill handle of a cell up or down to a destination cell.\n   * 4. Update all cells under a given cell by double clicking the cell's fill handle.\n   */\n  onRowsUpdate?: <E extends RowsUpdateEvent>(event: E) => void;\n\n  /**\n   * Dimensions props\n   */\n  /** The width of the grid in pixels */\n  width?: number;\n  /** The height of the grid in pixels */\n  height?: number;\n  /** Minimum column width in pixels */\n  minColumnWidth?: number;\n  /** The height of each row in pixels */\n  rowHeight?: number;\n  /** The height of the header row in pixels */\n  headerRowHeight?: number;\n  /** The height of the header filter row in pixels */\n  headerFiltersHeight?: number;\n\n  /**\n   * Feature props\n   */\n  /** Set of selected row keys */\n  selectedRows?: ReadonlySet<R[K]>;\n  /** Function called whenever row selection is changed */\n  onSelectedRowsChange?: (selectedRows: Set<R[K]>) => void;\n  /** The key of the column which is currently being sorted */\n  sortColumn?: string;\n  /** The direction to sort the sortColumn*/\n  sortDirection?: SortDirection;\n  /** Function called whenever grid is sorted*/\n  onSort?: (columnKey: string, direction: SortDirection) => void;\n  filters?: Filters;\n  onFiltersChange?: (filters: Filters) => void;\n\n  /**\n   * Custom renderers\n   */\n  defaultFormatter?: React.ComponentType<FormatterProps<R, SR>>;\n  rowRenderer?: React.ComponentType<RowRendererProps<R, SR>>;\n  emptyRowsRenderer?: React.ComponentType<{}>;\n\n  /**\n   * Event props\n   */\n  /** Function called whenever a row is clicked */\n  onRowClick?: (rowIdx: number, row: R, column: CalculatedColumn<R, SR>) => void;\n  /** Called when the grid is scrolled */\n  onScroll?: (event: React.UIEvent<HTMLDivElement>) => void;\n  /** Called when a column is resized */\n  onColumnResize?: (idx: number, width: number) => void;\n  /** Function called whenever selected cell is changed */\n  onSelectedCellChange?: (position: Position) => void;\n  /** called before cell is set active, returns a boolean to determine whether cell is editable */\n  onCheckCellIsEditable?: (event: CheckCellIsEditableEvent<R, SR>) => boolean;\n\n  /**\n   * Toggles and modes\n   */\n  /** Toggles whether filters row is displayed or not */\n  enableFilters?: boolean;\n  /** Toggles whether cells should be autofocused */\n  enableCellAutoFocus?: boolean;\n  enableCellCopyPaste?: boolean;\n  enableCellDragAndDrop?: boolean;\n  cellNavigationMode?: CellNavigationMode;\n\n  /**\n   * Miscellaneous\n   */\n  /** The node where the editor portal should mount. */\n  editorPortalTarget?: Element;\n}\n\n/**\n * Main API Component to render a data grid of rows and columns\n *\n * @example\n *\n * <DataGrid columns={columns} rows={rows} />\n*/\nfunction DataGrid<R, K extends keyof R, SR>({\n  // Grid and data Props\n  columns: rawColumns,\n  rows,\n  summaryRows,\n  rowKey,\n  onRowsUpdate,\n  // Dimensions props\n  width,\n  height = 350,\n  minColumnWidth = 80,\n  rowHeight = 35,\n  headerRowHeight = rowHeight,\n  headerFiltersHeight = 45,\n  // Feature props\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumn,\n  sortDirection,\n  onSort,\n  filters,\n  onFiltersChange,\n  // Custom renderers\n  defaultFormatter = ValueFormatter,\n  rowRenderer: RowRenderer = Row,\n  emptyRowsRenderer,\n  // Event props\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onCheckCellIsEditable,\n  // Toggles and modes\n  enableFilters = false,\n  enableCellAutoFocus = true,\n  enableCellCopyPaste = false,\n  enableCellDragAndDrop = false,\n  cellNavigationMode = CellNavigationMode.NONE,\n  // Miscellaneous\n  editorPortalTarget = document.body\n}: DataGridProps<R, K, SR>, ref: React.Ref<DataGridHandle>) {\n  /**\n   * refs\n   * */\n  const gridRef = useRef<HTMLDivElement>(null);\n  const lastSelectedRowIdx = useRef(-1);\n\n  /**\n   * states\n   */\n  const [eventBus] = useState(() => new EventBus());\n  const [gridWidth, setGridWidth] = useState(0);\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState<ReadonlyMap<string, number>>(() => new Map());\n\n  /**\n   * computed values\n   */\n  const viewportWidth = (width || gridWidth) - 2; // 2 for border width;\n\n  const { columns, lastFrozenColumnIndex, totalColumnWidth } = useMemo(() => {\n    return getColumnMetrics<R, SR>({\n      columns: rawColumns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultFormatter\n    });\n  }, [columnWidths, rawColumns, defaultFormatter, minColumnWidth, viewportWidth]);\n\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    return getHorizontalRangeToRender(\n      columns,\n      lastFrozenColumnIndex,\n      viewportWidth,\n      scrollLeft\n    );\n  }, [scrollLeft, columns, lastFrozenColumnIndex, viewportWidth]);\n\n  const viewportColumns = useMemo((): readonly CalculatedColumn<R, SR>[] => {\n    return getViewportColumns(\n      columns,\n      colOverscanStartIdx,\n      colOverscanEndIdx\n    );\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n\n  const totalHeaderHeight = headerRowHeight + (enableFilters ? headerFiltersHeight : 0);\n  const clientHeight = height\n    - 2 // border width\n    - totalHeaderHeight\n    - (summaryRows?.length ?? 0) * rowHeight\n    - (totalColumnWidth > viewportWidth ? getScrollbarSize() : 0);\n\n  const [rowOverscanStartIdx, rowOverscanEndIdx] = getVerticalRangeToRender(\n    clientHeight,\n    rowHeight,\n    scrollTop,\n    rows.length\n  );\n\n  /**\n   * effects\n   */\n  useLayoutEffect(() => {\n    // Do not calculate the width if width is provided\n    if (typeof width === 'number') return;\n    function onResize() {\n      // Immediately re-render when the component is mounted to get valid columnMetrics.\n      setGridWidth(gridRef.current!.getBoundingClientRect().width);\n    }\n    onResize();\n\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [width]);\n\n  useEffect(() => {\n    if (!onSelectedRowsChange) return;\n\n    const handleRowSelectionChange = ({ rowIdx, checked, isShiftClick }: SelectRowEvent) => {\n      assertIsValidKey(rowKey);\n      const newSelectedRows = new Set(selectedRows);\n      const rowId = rows[rowIdx][rowKey];\n\n      if (checked) {\n        newSelectedRows.add(rowId);\n        const previousRowIdx = lastSelectedRowIdx.current;\n        lastSelectedRowIdx.current = rowIdx;\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n          const step = Math.sign(rowIdx - previousRowIdx);\n          for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n            newSelectedRows.add(rows[i][rowKey]);\n          }\n        }\n      } else {\n        newSelectedRows.delete(rowId);\n        lastSelectedRowIdx.current = -1;\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n    };\n\n    return eventBus.subscribe('SELECT_ROW', handleRowSelectionChange);\n  }, [eventBus, onSelectedRowsChange, rows, rowKey, selectedRows]);\n\n  useImperativeHandle(ref, () => ({\n    scrollToColumn(idx: number) {\n      scrollToCell({ idx });\n    },\n    scrollToRow(rowIdx: number) {\n      const { current } = gridRef;\n      if (!current) return;\n      current.scrollTop = rowIdx * rowHeight;\n    },\n    selectCell(position: Position, openEditor?: boolean) {\n      eventBus.dispatch('SELECT_CELL', position, openEditor);\n    }\n  }));\n\n  /**\n   * event handlers\n   */\n  function onGridScroll(event: React.UIEvent<HTMLDivElement>) {\n    const { scrollTop, scrollLeft } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll?.(event);\n  }\n\n  const handleColumnResize = useCallback((column: CalculatedColumn<R, SR>, width: number) => {\n    const newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n\n    onColumnResize?.(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n\n  function handleRowsUpdate(event: RowsUpdateEvent) {\n    onRowsUpdate?.(event);\n  }\n\n  /**\n   * utils\n   */\n  function getFrozenColumnsWidth() {\n    if (lastFrozenColumnIndex === -1) return 0;\n    const lastFrozenCol = columns[lastFrozenColumnIndex];\n    return lastFrozenCol.left + lastFrozenCol.width;\n  }\n\n  function scrollToCell({ idx, rowIdx }: Partial<Position>) {\n    const { current } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const { clientWidth } = current;\n      const { left, width } = columns[idx];\n      const isCellAtLeftBoundary = left < scrollLeft + width + getFrozenColumnsWidth();\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        const newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      let key: string | number = rowIdx;\n      let isRowSelected = false;\n      if (rowKey !== undefined) {\n        const rowId = row[rowKey];\n        isRowSelected = selectedRows?.has(rowId) ?? false;\n        if (typeof rowId === 'string' || typeof rowId === 'number') {\n          key = rowId;\n        }\n      }\n\n      rowElements.push(\n        <RowRenderer\n          key={key}\n          rowIdx={rowIdx}\n          row={row}\n          viewportColumns={viewportColumns}\n          lastFrozenColumnIndex={lastFrozenColumnIndex}\n          eventBus={eventBus}\n          isRowSelected={isRowSelected}\n          onRowClick={onRowClick}\n        />\n      );\n    }\n\n    return rowElements;\n  }\n\n  return (\n    <div\n      className=\"rdg\"\n      style={{\n        width,\n        height,\n        '--header-row-height': `${headerRowHeight}px`,\n        '--filter-row-height': `${headerFiltersHeight}px`,\n        '--row-width': `${totalColumnWidth}px`,\n        '--row-height': `${rowHeight}px`\n      } as React.CSSProperties}\n      ref={gridRef}\n      onScroll={onGridScroll}\n    >\n      <HeaderRow<R, K, SR>\n        rowKey={rowKey}\n        rows={rows}\n        columns={viewportColumns}\n        onColumnResize={handleColumnResize}\n        lastFrozenColumnIndex={lastFrozenColumnIndex}\n        allRowsSelected={selectedRows?.size === rows.length}\n        onSelectedRowsChange={onSelectedRowsChange}\n        sortColumn={sortColumn}\n        sortDirection={sortDirection}\n        onSort={onSort}\n      />\n      {enableFilters && (\n        <FilterRow<R, SR>\n          lastFrozenColumnIndex={lastFrozenColumnIndex}\n          columns={viewportColumns}\n          filters={filters}\n          onFiltersChange={onFiltersChange}\n        />\n      )}\n      {rows.length === 0 && emptyRowsRenderer ? createElement(emptyRowsRenderer) : (\n        <>\n          {viewportWidth > 0 && (\n            <InteractionMasks<R, SR>\n              rows={rows}\n              rowHeight={rowHeight}\n              columns={columns}\n              enableCellAutoFocus={enableCellAutoFocus}\n              enableCellCopyPaste={enableCellCopyPaste}\n              enableCellDragAndDrop={enableCellDragAndDrop}\n              cellNavigationMode={cellNavigationMode}\n              eventBus={eventBus}\n              gridRef={gridRef}\n              totalHeaderHeight={totalHeaderHeight}\n              scrollLeft={scrollLeft}\n              scrollTop={scrollTop}\n              scrollToCell={scrollToCell}\n              editorPortalTarget={editorPortalTarget}\n              onCheckCellIsEditable={onCheckCellIsEditable}\n              onRowsUpdate={handleRowsUpdate}\n              onSelectedCellChange={onSelectedCellChange}\n            />\n          )}\n          <div style={{ height: rowOverscanStartIdx * rowHeight }} />\n          {getViewportRows()}\n          <div style={{ height: (rows.length - 1 - rowOverscanEndIdx) * rowHeight }} />\n          {summaryRows?.map((row, rowIdx) => (\n            <SummaryRow<R, SR>\n              key={rowIdx}\n              rowIdx={rowIdx}\n              row={row}\n              bottom={rowHeight * (summaryRows.length - 1 - rowIdx)}\n              viewportColumns={viewportColumns}\n              lastFrozenColumnIndex={lastFrozenColumnIndex}\n            />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default forwardRef(\n  DataGrid as React.RefForwardingComponent<DataGridHandle>\n) as <R, K extends keyof R, SR = unknown>(props: DataGridProps<R, K, SR> & { ref?: React.Ref<DataGridHandle> }) => JSX.Element;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"function getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex) {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nconst RENDER_BACTCH_SIZE = 8;\nexport function getVerticalRangeToRender(height, rowHeight, scrollTop, rowsCount) {\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  return [rowOverscanStartIdx, rowOverscanEndIdx];\n}\nexport function getHorizontalRangeToRender(columns, lastFrozenColumnIndex, viewportWidth, scrollLeft) {\n  // get the viewport's left side and right side positions for non-frozen columns\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  const viewportRight = scrollLeft + viewportWidth; // get first and last non-frozen column indexes\n\n  const lastColIdx = columns.length - 1;\n  const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx); // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n\n  if (viewportLeft >= viewportRight) {\n    return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n  } // get the first visible non-frozen column index\n\n\n  let colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n  while (colVisibleStartIdx < lastColIdx) {\n    const {\n      left,\n      width\n    } = columns[colVisibleStartIdx]; // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n\n    if (left + width > viewportLeft) {\n      break;\n    }\n\n    colVisibleStartIdx++;\n  } // get the last visible non-frozen column index\n\n\n  let colVisibleEndIdx = colVisibleStartIdx;\n\n  while (colVisibleEndIdx < lastColIdx) {\n    const {\n      left,\n      width\n    } = columns[colVisibleEndIdx]; // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n\n    if (left + width >= viewportRight) {\n      break;\n    }\n\n    colVisibleEndIdx++;\n  }\n\n  const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n  return [colOverscanStartIdx, colOverscanEndIdx];\n}\nexport function getViewportColumns(columns, colOverscanStartIdx, colOverscanEndIdx) {\n  const viewportColumns = [];\n\n  for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n    const column = columns[colIdx];\n    if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n    viewportColumns.push(column);\n  }\n\n  return viewportColumns;\n}","map":{"version":3,"sources":["../../src/utils/viewportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CalculatedColumn } from '../common/types';\n\nfunction getTotalFrozenColumnWidth<R, SR>(columns: readonly CalculatedColumn<R, SR>[], lastFrozenColumnIndex: number): number {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nconst RENDER_BACTCH_SIZE = 8;\n\nexport function getVerticalRangeToRender(\n  height: number,\n  rowHeight: number,\n  scrollTop: number,\n  rowsCount: number\n) {\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return [rowOverscanStartIdx, rowOverscanEndIdx] as const;\n}\n\nexport function getHorizontalRangeToRender<R, SR>(\n  columns: readonly CalculatedColumn<R, SR>[],\n  lastFrozenColumnIndex: number,\n  viewportWidth: number,\n  scrollLeft: number\n): [number, number] {\n  // get the viewport's left side and right side positions for non-frozen columns\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  const viewportRight = scrollLeft + viewportWidth;\n  // get first and last non-frozen column indexes\n  const lastColIdx = columns.length - 1;\n  const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n  // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n  if (viewportLeft >= viewportRight) {\n    return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n  }\n\n  // get the first visible non-frozen column index\n  let colVisibleStartIdx = firstUnfrozenColumnIdx;\n  while (colVisibleStartIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleStartIdx];\n    // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n    if (left + width > viewportLeft) {\n      break;\n    }\n    colVisibleStartIdx++;\n  }\n\n  // get the last visible non-frozen column index\n  let colVisibleEndIdx = colVisibleStartIdx;\n  while (colVisibleEndIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleEndIdx];\n    // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n    if (left + width >= viewportRight) {\n      break;\n    }\n    colVisibleEndIdx++;\n  }\n\n  const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n  return [colOverscanStartIdx, colOverscanEndIdx];\n}\n\nexport function getViewportColumns<R, SR>(columns: readonly CalculatedColumn<R, SR>[], colOverscanStartIdx: number, colOverscanEndIdx: number) {\n  const viewportColumns: CalculatedColumn<R, SR>[] = [];\n  for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n    const column = columns[colIdx];\n\n    if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n    viewportColumns.push(column);\n  }\n\n  return viewportColumns;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
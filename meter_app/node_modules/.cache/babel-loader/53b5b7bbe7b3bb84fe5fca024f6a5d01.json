{"ast":null,"code":"import React, { useRef, useEffect } from 'react';\nexport default function ClickOutside({\n  onClickOutside,\n  children\n}) {\n  const isClickedInside = useRef(false);\n  useEffect(() => {\n    function handleDocumentClick() {\n      if (isClickedInside.current) {\n        isClickedInside.current = false;\n      } else {\n        onClickOutside();\n      }\n    }\n\n    document.addEventListener('click', handleDocumentClick);\n    return () => {\n      document.removeEventListener('click', handleDocumentClick);\n    };\n  }, [onClickOutside]);\n  return React.cloneElement(React.Children.only(children), {\n    onClickCapture() {\n      isClickedInside.current = true;\n    }\n\n  });\n}","map":{"version":3,"sources":["../../src/editors/ClickOutside.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAP,IAAgB,MAAhB,EAAwB,SAAxB,QAAyC,OAAzC;AAwDA,eAAc,SAAU,YAAV,CAAuB;AAAE,EAAA,cAAF;AAAkB,EAAA;AAAlB,CAAvB,EAA0D;AACtE,QAAM,eAAe,GAAG,MAAM,CAAC,KAAD,CAA9B;AAEA,EAAA,SAAS,CAAC,MAAK;AACb,aAAS,mBAAT,GAA4B;AAC1B,UAAI,eAAe,CAAC,OAApB,EAA6B;AAC3B,QAAA,eAAe,CAAC,OAAhB,GAA0B,KAA1B;AACD,OAFD,MAEO;AACL,QAAA,cAAc;AACf;AACF;;AAED,IAAA,QAAQ,CAAC,gBAAT,CAA0B,OAA1B,EAAmC,mBAAnC;AACA,WAAO,MAAK;AACV,MAAA,QAAQ,CAAC,mBAAT,CAA6B,OAA7B,EAAsC,mBAAtC;AACD,KAFD;AAGD,GAbQ,EAaN,CAAC,cAAD,CAbM,CAAT;AAeA,SAAO,KAAK,CAAC,YAAN,CACL,KAAK,CAAC,QAAN,CAAe,IAAf,CAAoB,QAApB,CADK,EAC0B;AAC7B,IAAA,cAAc,GAAA;AACZ,MAAA,eAAe,CAAC,OAAhB,GAA0B,IAA1B;AACD;;AAH4B,GAD1B,CAAP;AAOD","sourcesContent":["import React, { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div react-data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div react-data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the document\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the document click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the document is set using document.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\ninterface Props {\n  children: React.ReactElement;\n  onClickOutside: () => void;\n}\n\nexport default function ClickOutside({ onClickOutside, children }: Props) {\n  const isClickedInside = useRef(false);\n\n  useEffect(() => {\n    function handleDocumentClick() {\n      if (isClickedInside.current) {\n        isClickedInside.current = false;\n      } else {\n        onClickOutside();\n      }\n    }\n\n    document.addEventListener('click', handleDocumentClick);\n    return () => {\n      document.removeEventListener('click', handleDocumentClick);\n    };\n  }, [onClickOutside]);\n\n  return React.cloneElement(\n    React.Children.only(children), {\n      onClickCapture() {\n        isClickedInside.current = true;\n      }\n    }\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
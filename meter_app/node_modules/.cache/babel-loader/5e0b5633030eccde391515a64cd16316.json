{"ast":null,"code":"import React, { useState, useRef, useEffect, useCallback } from 'react'; // Components\n\nimport CellMask from './CellMask';\nimport DragMask from './DragMask';\nimport EditorContainer from '../editors/EditorContainer';\nimport EditorPortal from '../editors/EditorPortal';\nimport { legacyCellInput } from '../editors/CellInputHandlers'; // Utils\n\nimport { isCtrlKeyHeldDown, getSelectedDimensions as getDimensions, getNextSelectedCellPosition, canExitGrid, isSelectedCellEditable } from '../utils';\nimport { UpdateActions, CellNavigationMode } from '../common/enums';\nexport default function InteractionMasks({\n  columns,\n  rows,\n  rowHeight,\n  eventBus,\n  enableCellAutoFocus,\n  enableCellCopyPaste,\n  enableCellDragAndDrop,\n  editorPortalTarget,\n  cellNavigationMode,\n  gridRef,\n  totalHeaderHeight,\n  scrollLeft,\n  scrollTop,\n  onSelectedCellChange,\n  onCheckCellIsEditable,\n  onRowsUpdate,\n  scrollToCell\n}) {\n  const [selectedPosition, setSelectedPosition] = useState(() => {\n    if (enableCellAutoFocus && document.activeElement === document.body && columns.length > 0 && rows.length > 0) {\n      return {\n        idx: 0,\n        rowIdx: 0,\n        status: 'SELECT'\n      };\n    }\n\n    return {\n      idx: -1,\n      rowIdx: -1,\n      status: 'SELECT'\n    };\n  });\n  const [copiedPosition, setCopiedPosition] = useState(null);\n  const [draggedPosition, setDraggedPosition] = useState(null);\n  const selectionMaskRef = useRef(null); // Focus on the selection mask when the selected position is changed or the editor is closed\n\n  useEffect(() => {\n    var _a;\n\n    if (selectedPosition.rowIdx === -1 || selectedPosition.idx === -1 || selectedPosition.status === 'EDIT') return;\n    (_a = selectionMaskRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n  }, [selectedPosition]);\n  useEffect(() => {\n    return eventBus.subscribe('SELECT_CELL', selectCell);\n  });\n  useEffect(() => {\n    if (draggedPosition === null) return;\n\n    const handleDragEnter = overRowIdx => {\n      setDraggedPosition({ ...draggedPosition,\n        overRowIdx\n      });\n    };\n\n    return eventBus.subscribe('DRAG_ENTER', handleDragEnter);\n  }, [draggedPosition, eventBus]);\n  const closeEditor = useCallback(() => {\n    setSelectedPosition(({\n      idx,\n      rowIdx\n    }) => ({\n      idx,\n      rowIdx,\n      status: 'SELECT'\n    }));\n  }, []); // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n\n  if (selectedPosition.idx > columns.length || selectedPosition.rowIdx > rows.length) {\n    setSelectedPosition({\n      idx: -1,\n      rowIdx: -1,\n      status: 'SELECT'\n    });\n    setCopiedPosition(null);\n    setDraggedPosition(null);\n  }\n\n  function getEditorPosition() {\n    if (gridRef.current === null) return {\n      left: 0,\n      top: 0\n    };\n    const {\n      left,\n      top\n    } = gridRef.current.getBoundingClientRect();\n    const {\n      scrollTop: docTop,\n      scrollLeft: docLeft\n    } = document.scrollingElement || document.documentElement;\n    const gridLeft = left + docLeft;\n    const gridTop = top + docTop;\n    const column = columns[selectedPosition.idx];\n    return {\n      left: gridLeft + column.left - (column.frozen ? 0 : scrollLeft),\n      top: gridTop + totalHeaderHeight + selectedPosition.rowIdx * rowHeight - scrollTop\n    };\n  }\n\n  function getNextPosition(key, mode = cellNavigationMode, shiftKey = false) {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    let nextPosition;\n\n    switch (key) {\n      case 'ArrowUp':\n        nextPosition = {\n          idx,\n          rowIdx: rowIdx - 1\n        };\n        break;\n\n      case 'ArrowDown':\n        nextPosition = {\n          idx,\n          rowIdx: rowIdx + 1\n        };\n        break;\n\n      case 'ArrowLeft':\n        nextPosition = {\n          idx: idx - 1,\n          rowIdx\n        };\n        break;\n\n      case 'ArrowRight':\n        nextPosition = {\n          idx: idx + 1,\n          rowIdx\n        };\n        break;\n\n      case 'Tab':\n        nextPosition = {\n          idx: idx + (shiftKey ? -1 : 1),\n          rowIdx\n        };\n        break;\n\n      default:\n        nextPosition = {\n          idx,\n          rowIdx\n        };\n        break;\n    }\n\n    return getNextSelectedCellPosition({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n  }\n\n  function onKeyDown(event) {\n    var _a;\n\n    const column = columns[selectedPosition.idx];\n    const row = rows[selectedPosition.rowIdx];\n    const isActivatedByUser = ((_a = column.unsafe_onCellInput) !== null && _a !== void 0 ? _a : legacyCellInput)(event, row) === true;\n    const {\n      key\n    } = event;\n\n    if (enableCellCopyPaste && isCtrlKeyHeldDown(event)) {\n      // event.key may be uppercase `C` or `V`\n      const lowerCaseKey = event.key.toLowerCase();\n      if (lowerCaseKey === 'c') return handleCopy();\n      if (lowerCaseKey === 'v') return handlePaste();\n    }\n\n    const canOpenEditor = selectedPosition.status === 'SELECT' && isCellEditable(selectedPosition);\n\n    switch (key) {\n      case 'Enter':\n        if (canOpenEditor) {\n          setSelectedPosition(({\n            idx,\n            rowIdx\n          }) => ({\n            idx,\n            rowIdx,\n            status: 'EDIT',\n            key: 'Enter'\n          }));\n        } else if (selectedPosition.status === 'EDIT') {\n          setSelectedPosition(({\n            idx,\n            rowIdx\n          }) => ({\n            idx,\n            rowIdx,\n            status: 'SELECT'\n          }));\n        }\n\n        break;\n\n      case 'Escape':\n        closeEditor();\n        setCopiedPosition(null);\n        break;\n\n      case 'Tab':\n        onPressTab(event);\n        break;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        event.preventDefault();\n        selectCell(getNextPosition(key));\n        break;\n\n      default:\n        if (canOpenEditor && isActivatedByUser) {\n          setSelectedPosition(({\n            idx,\n            rowIdx\n          }) => ({\n            idx,\n            rowIdx,\n            status: 'EDIT',\n            key\n          }));\n        }\n\n        break;\n    }\n  }\n\n  function onPressTab(e) {\n    // If we are in a position to leave the grid, stop editing but stay in that cell\n    if (canExitGrid(e, {\n      cellNavigationMode,\n      columns,\n      rowsCount: rows.length,\n      selectedPosition\n    })) {\n      if (selectedPosition.status === 'EDIT') {\n        closeEditor();\n        return;\n      } // Reset the selected position before exiting\n\n\n      setSelectedPosition({\n        idx: -1,\n        rowIdx: -1,\n        status: 'SELECT'\n      });\n      return;\n    }\n\n    e.preventDefault();\n    const tabCellNavigationMode = cellNavigationMode === CellNavigationMode.NONE ? CellNavigationMode.CHANGE_ROW : cellNavigationMode;\n    const nextPosition = getNextPosition('Tab', tabCellNavigationMode, e.shiftKey);\n    selectCell(nextPosition);\n  }\n\n  function handleCopy() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const value = rows[rowIdx][columns[idx].key];\n    setCopiedPosition({\n      idx,\n      rowIdx,\n      value\n    });\n  }\n\n  function handlePaste() {\n    if (copiedPosition === null || !isCellEditable(selectedPosition)) {\n      return;\n    }\n\n    const {\n      rowIdx: toRow\n    } = selectedPosition;\n    const cellKey = columns[selectedPosition.idx].key;\n    const {\n      rowIdx: fromRow,\n      idx,\n      value\n    } = copiedPosition;\n    const fromCellKey = columns[idx].key;\n    onRowsUpdate({\n      cellKey,\n      fromRow,\n      toRow,\n      updated: {\n        [cellKey]: value\n      },\n      action: UpdateActions.COPY_PASTE,\n      fromCellKey\n    });\n  }\n\n  function isCellWithinBounds({\n    idx,\n    rowIdx\n  }) {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= 0 && idx < columns.length;\n  }\n\n  function isCellEditable(position) {\n    return isCellWithinBounds(position) && isSelectedCellEditable({\n      columns,\n      rows,\n      selectedPosition: position,\n      onCheckCellIsEditable\n    });\n  }\n\n  function selectCell(position, enableEditor = false) {\n    if (!isCellWithinBounds(position)) return;\n\n    if (enableEditor && isCellEditable(position)) {\n      setSelectedPosition({ ...position,\n        status: 'EDIT',\n        key: null\n      });\n    } else {\n      setSelectedPosition({ ...position,\n        status: 'SELECT'\n      });\n    }\n\n    scrollToCell(position);\n    onSelectedCellChange === null || onSelectedCellChange === void 0 ? void 0 : onSelectedCellChange({ ...position\n    });\n  }\n\n  function isDragEnabled() {\n    return enableCellDragAndDrop && isCellEditable(selectedPosition);\n  }\n\n  function handleDragStart(e) {\n    e.dataTransfer.effectAllowed = 'copy'; // Setting data is required to make an element draggable in FF\n\n    const transferData = JSON.stringify(selectedPosition);\n\n    try {\n      e.dataTransfer.setData('text/plain', transferData);\n    } catch (ex) {\n      // IE only supports 'text' and 'URL' for the 'type' argument\n      e.dataTransfer.setData('text', transferData);\n    }\n\n    setDraggedPosition({ ...selectedPosition,\n      overRowIdx: selectedPosition.rowIdx\n    });\n  }\n\n  function handleDragEnd() {\n    if (draggedPosition === null) return;\n    const {\n      rowIdx,\n      overRowIdx\n    } = draggedPosition;\n    const column = columns[draggedPosition.idx];\n    const cellKey = column.key;\n    const value = rows[rowIdx][cellKey];\n    onRowsUpdate({\n      cellKey,\n      fromRow: rowIdx,\n      toRow: overRowIdx,\n      updated: {\n        [cellKey]: value\n      },\n      action: UpdateActions.CELL_DRAG\n    });\n    setDraggedPosition(null);\n  }\n\n  function onDragHandleDoubleClick() {\n    const column = columns[selectedPosition.idx];\n    const cellKey = column.key;\n    const value = rows[selectedPosition.rowIdx][cellKey];\n    onRowsUpdate({\n      cellKey,\n      fromRow: selectedPosition.rowIdx,\n      toRow: rows.length - 1,\n      updated: {\n        [cellKey]: value\n      },\n      action: UpdateActions.COLUMN_FILL\n    });\n  }\n\n  function onCommit({\n    cellKey,\n    rowIdx,\n    updated\n  }) {\n    onRowsUpdate({\n      cellKey,\n      fromRow: rowIdx,\n      toRow: rowIdx,\n      updated,\n      action: UpdateActions.CELL_UPDATE\n    });\n    closeEditor();\n  }\n\n  function getSelectedDimensions(selectedPosition) {\n    return getDimensions({\n      selectedPosition,\n      columns,\n      scrollLeft,\n      rowHeight\n    });\n  }\n\n  return React.createElement(\"div\", {\n    onKeyDown: onKeyDown\n  }, copiedPosition && isCellWithinBounds(copiedPosition) && React.createElement(CellMask, Object.assign({\n    className: \"rdg-cell-copied\"\n  }, getSelectedDimensions(copiedPosition))), draggedPosition && isCellWithinBounds(draggedPosition) && React.createElement(DragMask, {\n    draggedPosition: draggedPosition,\n    getSelectedDimensions: getSelectedDimensions\n  }), selectedPosition.status === 'SELECT' && isCellWithinBounds(selectedPosition) && React.createElement(CellMask, Object.assign({\n    className: \"rdg-selected\",\n    tabIndex: 0,\n    ref: selectionMaskRef\n  }, getSelectedDimensions(selectedPosition)), isDragEnabled() && React.createElement(\"div\", {\n    className: \"drag-handle\",\n    draggable: true,\n    onDragStart: handleDragStart,\n    onDragEnd: handleDragEnd,\n    onDoubleClick: onDragHandleDoubleClick\n  })), selectedPosition.status === 'EDIT' && isCellWithinBounds(selectedPosition) && React.createElement(EditorPortal, {\n    target: editorPortalTarget\n  }, React.createElement(EditorContainer, Object.assign({\n    firstEditorKeyPress: selectedPosition.key,\n    onCommit: onCommit,\n    onCommitCancel: closeEditor,\n    rowIdx: selectedPosition.rowIdx,\n    row: rows[selectedPosition.rowIdx],\n    rowHeight: rowHeight,\n    column: columns[selectedPosition.idx],\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  }, getEditorPosition()))));\n}","map":{"version":3,"sources":["../../src/masks/InteractionMasks.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { useState, useRef, useEffect, useCallback } from 'react';\n\n// Components\nimport CellMask from './CellMask';\nimport DragMask, { DraggedPosition } from './DragMask';\nimport EditorContainer from '../editors/EditorContainer';\nimport EditorPortal from '../editors/EditorPortal';\nimport { legacyCellInput } from '../editors/CellInputHandlers';\n\n// Utils\nimport {\n  isCtrlKeyHeldDown,\n  getSelectedDimensions as getDimensions,\n  getNextSelectedCellPosition,\n  canExitGrid,\n  isSelectedCellEditable\n} from '../utils';\n\n// Types\nimport EventBus from '../EventBus';\nimport { UpdateActions, CellNavigationMode } from '../common/enums';\nimport { CalculatedColumn, Position, Dimension, CommitEvent } from '../common/types';\nimport { DataGridProps } from '../DataGrid';\n\ntype SharedCanvasProps<R, SR> = Pick<DataGridProps<R, never, SR>,\n  | 'rows'\n  | 'onCheckCellIsEditable'\n  | 'onSelectedCellChange'\n> & Pick<Required<DataGridProps<R, never, SR>>,\n  | 'rowHeight'\n  | 'enableCellAutoFocus'\n  | 'enableCellCopyPaste'\n  | 'enableCellDragAndDrop'\n  | 'cellNavigationMode'\n  | 'editorPortalTarget'\n  | 'onRowsUpdate'\n>;\n\ninterface SelectCellState extends Position {\n  status: 'SELECT';\n}\n\ninterface EditCellState extends Position {\n  status: 'EDIT';\n  key: string | null;\n}\n\nexport interface InteractionMasksProps<R, SR> extends SharedCanvasProps<R, SR> {\n  columns: readonly CalculatedColumn<R, SR>[];\n  gridRef: React.RefObject<HTMLDivElement>;\n  totalHeaderHeight: number;\n  scrollLeft: number;\n  scrollTop: number;\n  eventBus: EventBus;\n  scrollToCell: (cell: Position) => void;\n}\n\nexport default function InteractionMasks<R, SR>({\n  columns,\n  rows,\n  rowHeight,\n  eventBus,\n  enableCellAutoFocus,\n  enableCellCopyPaste,\n  enableCellDragAndDrop,\n  editorPortalTarget,\n  cellNavigationMode,\n  gridRef,\n  totalHeaderHeight,\n  scrollLeft,\n  scrollTop,\n  onSelectedCellChange,\n  onCheckCellIsEditable,\n  onRowsUpdate,\n  scrollToCell\n}: InteractionMasksProps<R, SR>) {\n  const [selectedPosition, setSelectedPosition] = useState<SelectCellState | EditCellState>(() => {\n    if (enableCellAutoFocus && document.activeElement === document.body && columns.length > 0 && rows.length > 0) {\n      return { idx: 0, rowIdx: 0, status: 'SELECT' };\n    }\n    return { idx: -1, rowIdx: -1, status: 'SELECT' };\n  });\n  const [copiedPosition, setCopiedPosition] = useState<Position & { value: unknown } | null>(null);\n  const [draggedPosition, setDraggedPosition] = useState<DraggedPosition | null>(null);\n  const selectionMaskRef = useRef<HTMLDivElement>(null);\n\n  // Focus on the selection mask when the selected position is changed or the editor is closed\n  useEffect(() => {\n    if (selectedPosition.rowIdx === -1 || selectedPosition.idx === -1 || selectedPosition.status === 'EDIT') return;\n    selectionMaskRef.current?.focus();\n  }, [selectedPosition]);\n\n  useEffect(() => {\n    return eventBus.subscribe('SELECT_CELL', selectCell);\n  });\n\n  useEffect(() => {\n    if (draggedPosition === null) return;\n    const handleDragEnter = (overRowIdx: number) => {\n      setDraggedPosition({ ...draggedPosition, overRowIdx });\n    };\n    return eventBus.subscribe('DRAG_ENTER', handleDragEnter);\n  }, [draggedPosition, eventBus]);\n\n  const closeEditor = useCallback(() => {\n    setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, status: 'SELECT' }));\n  }, []);\n\n  // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n  if (selectedPosition.idx > columns.length || selectedPosition.rowIdx > rows.length) {\n    setSelectedPosition({ idx: -1, rowIdx: -1, status: 'SELECT' });\n    setCopiedPosition(null);\n    setDraggedPosition(null);\n  }\n\n  function getEditorPosition() {\n    if (gridRef.current === null) return { left: 0, top: 0 };\n    const { left, top } = gridRef.current.getBoundingClientRect();\n    const { scrollTop: docTop, scrollLeft: docLeft } = document.scrollingElement || document.documentElement;\n    const gridLeft = left + docLeft;\n    const gridTop = top + docTop;\n    const column = columns[selectedPosition.idx];\n    return {\n      left: gridLeft + column.left - (column.frozen ? 0 : scrollLeft),\n      top: gridTop + totalHeaderHeight + selectedPosition.rowIdx * rowHeight - scrollTop\n    };\n  }\n\n  function getNextPosition(key: string, mode = cellNavigationMode, shiftKey = false) {\n    const { idx, rowIdx } = selectedPosition;\n    let nextPosition: Position;\n    switch (key) {\n      case 'ArrowUp':\n        nextPosition = { idx, rowIdx: rowIdx - 1 };\n        break;\n      case 'ArrowDown':\n        nextPosition = { idx, rowIdx: rowIdx + 1 };\n        break;\n      case 'ArrowLeft':\n        nextPosition = { idx: idx - 1, rowIdx };\n        break;\n      case 'ArrowRight':\n        nextPosition = { idx: idx + 1, rowIdx };\n        break;\n      case 'Tab':\n        nextPosition = { idx: idx + (shiftKey ? -1 : 1), rowIdx };\n        break;\n      default:\n        nextPosition = { idx, rowIdx };\n        break;\n    }\n\n    return getNextSelectedCellPosition<R, SR>({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n  }\n\n  function onKeyDown(event: React.KeyboardEvent<HTMLDivElement>): void {\n    const column = columns[selectedPosition.idx];\n    const row = rows[selectedPosition.rowIdx];\n    const isActivatedByUser = (column.unsafe_onCellInput ?? legacyCellInput)(event, row) === true;\n\n    const { key } = event;\n    if (enableCellCopyPaste && isCtrlKeyHeldDown(event)) {\n      // event.key may be uppercase `C` or `V`\n      const lowerCaseKey = event.key.toLowerCase();\n      if (lowerCaseKey === 'c') return handleCopy();\n      if (lowerCaseKey === 'v') return handlePaste();\n    }\n\n    const canOpenEditor = selectedPosition.status === 'SELECT' && isCellEditable(selectedPosition);\n\n    switch (key) {\n      case 'Enter':\n        if (canOpenEditor) {\n          setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, status: 'EDIT', key: 'Enter' }));\n        } else if (selectedPosition.status === 'EDIT') {\n          setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, status: 'SELECT' }));\n        }\n        break;\n      case 'Escape':\n        closeEditor();\n        setCopiedPosition(null);\n        break;\n      case 'Tab':\n        onPressTab(event);\n        break;\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        event.preventDefault();\n        selectCell(getNextPosition(key));\n        break;\n      default:\n        if (canOpenEditor && isActivatedByUser) {\n          setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, status: 'EDIT', key }));\n        }\n        break;\n    }\n  }\n\n  function onPressTab(e: React.KeyboardEvent<HTMLDivElement>): void {\n    // If we are in a position to leave the grid, stop editing but stay in that cell\n    if (canExitGrid(e, { cellNavigationMode, columns, rowsCount: rows.length, selectedPosition })) {\n      if (selectedPosition.status === 'EDIT') {\n        closeEditor();\n        return;\n      }\n\n      // Reset the selected position before exiting\n      setSelectedPosition({ idx: -1, rowIdx: -1, status: 'SELECT' });\n      return;\n    }\n\n    e.preventDefault();\n    const tabCellNavigationMode = cellNavigationMode === CellNavigationMode.NONE\n      ? CellNavigationMode.CHANGE_ROW\n      : cellNavigationMode;\n    const nextPosition = getNextPosition('Tab', tabCellNavigationMode, e.shiftKey);\n    selectCell(nextPosition);\n  }\n\n  function handleCopy(): void {\n    const { idx, rowIdx } = selectedPosition;\n    const value = rows[rowIdx][columns[idx].key as keyof R];\n    setCopiedPosition({ idx, rowIdx, value });\n  }\n\n  function handlePaste(): void {\n    if (copiedPosition === null || !isCellEditable(selectedPosition)) {\n      return;\n    }\n\n    const { rowIdx: toRow } = selectedPosition;\n\n    const cellKey = columns[selectedPosition.idx].key;\n    const { rowIdx: fromRow, idx, value } = copiedPosition;\n    const fromCellKey = columns[idx].key;\n\n    onRowsUpdate({\n      cellKey,\n      fromRow,\n      toRow,\n      updated: { [cellKey]: value } as never,\n      action: UpdateActions.COPY_PASTE,\n      fromCellKey\n    });\n  }\n\n  function isCellWithinBounds({ idx, rowIdx }: Position): boolean {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= 0 && idx < columns.length;\n  }\n\n  function isCellEditable(position: Position) {\n    return isCellWithinBounds(position)\n      && isSelectedCellEditable<R, SR>({ columns, rows, selectedPosition: position, onCheckCellIsEditable });\n  }\n\n  function selectCell(position: Position, enableEditor = false): void {\n    if (!isCellWithinBounds(position)) return;\n\n    if (enableEditor && isCellEditable(position)) {\n      setSelectedPosition({ ...position, status: 'EDIT', key: null });\n    } else {\n      setSelectedPosition({ ...position, status: 'SELECT' });\n    }\n    scrollToCell(position);\n    onSelectedCellChange?.({ ...position });\n  }\n\n  function isDragEnabled(): boolean {\n    return enableCellDragAndDrop && isCellEditable(selectedPosition);\n  }\n\n  function handleDragStart(e: React.DragEvent<HTMLDivElement>): void {\n    e.dataTransfer.effectAllowed = 'copy';\n    // Setting data is required to make an element draggable in FF\n    const transferData = JSON.stringify(selectedPosition);\n    try {\n      e.dataTransfer.setData('text/plain', transferData);\n    } catch (ex) {\n      // IE only supports 'text' and 'URL' for the 'type' argument\n      e.dataTransfer.setData('text', transferData);\n    }\n    setDraggedPosition({ ...selectedPosition, overRowIdx: selectedPosition.rowIdx });\n  }\n\n  function handleDragEnd() {\n    if (draggedPosition === null) return;\n\n    const { rowIdx, overRowIdx } = draggedPosition;\n    const column = columns[draggedPosition.idx];\n    const cellKey = column.key;\n    const value = rows[rowIdx][cellKey as keyof R];\n\n    onRowsUpdate({\n      cellKey,\n      fromRow: rowIdx,\n      toRow: overRowIdx,\n      updated: { [cellKey]: value } as never,\n      action: UpdateActions.CELL_DRAG\n    });\n\n    setDraggedPosition(null);\n  }\n\n  function onDragHandleDoubleClick(): void {\n    const column = columns[selectedPosition.idx];\n    const cellKey = column.key;\n    const value = rows[selectedPosition.rowIdx][cellKey as keyof R];\n\n    onRowsUpdate({\n      cellKey,\n      fromRow: selectedPosition.rowIdx,\n      toRow: rows.length - 1,\n      updated: { [cellKey]: value } as never,\n      action: UpdateActions.COLUMN_FILL\n    });\n  }\n\n  function onCommit({ cellKey, rowIdx, updated }: CommitEvent): void {\n    onRowsUpdate({\n      cellKey,\n      fromRow: rowIdx,\n      toRow: rowIdx,\n      updated,\n      action: UpdateActions.CELL_UPDATE\n    });\n    closeEditor();\n  }\n\n  function getSelectedDimensions(selectedPosition: Position): Dimension {\n    return getDimensions({ selectedPosition, columns, scrollLeft, rowHeight });\n  }\n\n  return (\n    <div onKeyDown={onKeyDown}>\n      {copiedPosition && isCellWithinBounds(copiedPosition) && (\n        <CellMask\n          className=\"rdg-cell-copied\"\n          {...getSelectedDimensions(copiedPosition)}\n        />\n      )}\n      {draggedPosition && isCellWithinBounds(draggedPosition) && (\n        <DragMask\n          draggedPosition={draggedPosition}\n          getSelectedDimensions={getSelectedDimensions}\n        />\n      )}\n      {selectedPosition.status === 'SELECT' && isCellWithinBounds(selectedPosition) && (\n        <CellMask\n          className=\"rdg-selected\"\n          tabIndex={0}\n          ref={selectionMaskRef}\n          {...getSelectedDimensions(selectedPosition)}\n        >\n          {isDragEnabled() && (\n            <div\n              className=\"drag-handle\"\n              draggable\n              onDragStart={handleDragStart}\n              onDragEnd={handleDragEnd}\n              onDoubleClick={onDragHandleDoubleClick}\n            />\n          )}\n        </CellMask>\n      )}\n      {selectedPosition.status === 'EDIT' && isCellWithinBounds(selectedPosition) && (\n        <EditorPortal target={editorPortalTarget}>\n          <EditorContainer<R, SR>\n            firstEditorKeyPress={selectedPosition.key}\n            onCommit={onCommit}\n            onCommitCancel={closeEditor}\n            rowIdx={selectedPosition.rowIdx}\n            row={rows[selectedPosition.rowIdx]}\n            rowHeight={rowHeight}\n            column={columns[selectedPosition.idx]}\n            scrollLeft={scrollLeft}\n            scrollTop={scrollTop}\n            {...getEditorPosition()}\n          />\n        </EditorPortal>\n      )}\n    </div>\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
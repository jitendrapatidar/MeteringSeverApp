{"ast":null,"code":"import { getScrollbarSize } from './domUtils';\nexport function getColumnMetrics(metrics) {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  const columns = [];\n\n  for (const metricsColumn of metrics.columns) {\n    let width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth);\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    const column = { ...metricsColumn,\n      width\n    };\n\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n      columns.splice(lastFrozenColumnIndex, 0, column);\n    } else {\n      columns.push(column);\n    }\n  }\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  const unallocatedColumnWidth = Math.max(Math.floor(unallocatedWidth / unassignedColumnsCount), metrics.minColumnWidth);\n  const calculatedColumns = columns.map((column, idx) => {\n    var _a, _b; // Every column should have a valid width as this stage\n\n\n    const width = (_a = column.width) !== null && _a !== void 0 ? _a : clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n    const newColumn = { ...column,\n      idx,\n      width,\n      left,\n      formatter: (_b = column.formatter) !== null && _b !== void 0 ? _b : metrics.defaultFormatter\n    };\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth\n  };\n}\n\nfunction getSpecifiedWidth({\n  key,\n  width\n}, columnWidths, viewportWidth) {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n\n  if (typeof width === 'number') {\n    return width;\n  }\n\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n\n  return undefined;\n}\n\nfunction clampColumnWidth(width, {\n  minWidth,\n  maxWidth\n}, minColumnWidth) {\n  width = Math.max(width, minWidth !== null && minWidth !== void 0 ? minWidth : minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n} // Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\n\n\nexport function canEdit(column, row) {\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n\n  return Boolean(column.editor || column.editable);\n}\nexport function getColumnScrollPosition(columns, idx, currentScrollLeft, currentClientWidth) {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../src/utils/columnUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Column, CalculatedColumn, FormatterProps, Omit } from '../common/types';\nimport { getScrollbarSize } from './domUtils';\n\ninterface Metrics<R, SR> {\n  columns: readonly Column<R, SR>[];\n  columnWidths: ReadonlyMap<string, number>;\n  minColumnWidth: number;\n  viewportWidth: number;\n  defaultFormatter: React.ComponentType<FormatterProps<R, SR>>;\n}\n\ninterface ColumnMetrics<TRow, TSummaryRow> {\n  columns: readonly CalculatedColumn<TRow, TSummaryRow>[];\n  lastFrozenColumnIndex: number;\n  totalColumnWidth: number;\n}\n\nexport function getColumnMetrics<R, SR>(metrics: Metrics<R, SR>): ColumnMetrics<R, SR> {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  const columns: Array<Omit<Column<R, SR>, 'width'> & { width: number | undefined }> = [];\n\n  for (const metricsColumn of metrics.columns) {\n    let width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth);\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    const column = { ...metricsColumn, width };\n\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n      columns.splice(lastFrozenColumnIndex, 0, column);\n    } else {\n      columns.push(column);\n    }\n  }\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  const unallocatedColumnWidth = Math.max(\n    Math.floor(unallocatedWidth / unassignedColumnsCount),\n    metrics.minColumnWidth\n  );\n\n  const calculatedColumns: CalculatedColumn<R, SR>[] = columns.map((column, idx) => {\n    // Every column should have a valid width as this stage\n    const width = column.width ?? clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n    const newColumn = {\n      ...column,\n      idx,\n      width,\n      left,\n      formatter: column.formatter ?? metrics.defaultFormatter\n    };\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth\n  };\n}\n\nfunction getSpecifiedWidth<R, SR>(\n  { key, width }: Column<R, SR>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R, SR>(\n  width: number,\n  { minWidth, maxWidth }: Column<R, SR>,\n  minColumnWidth: number\n): number {\n  width = Math.max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n\n// Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\nexport function canEdit<R, SR>(column: CalculatedColumn<R, SR>, row: R): boolean {\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n  return Boolean(column.editor || column.editable);\n}\n\nexport function getColumnScrollPosition<R, SR>(columns: readonly CalculatedColumn<R, SR>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
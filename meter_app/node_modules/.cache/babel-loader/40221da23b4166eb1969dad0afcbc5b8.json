{"ast":null,"code":"import { CellNavigationMode } from '../common/enums';\nimport { canEdit } from './columnUtils'; // above unfrozen cells, below frozen cells\n\nconst zCellMask = 1; // above frozen cells, below header/filter/summary rows\n\nconst zFrozenCellMask = 2;\nexport function getSelectedDimensions({\n  selectedPosition: {\n    idx,\n    rowIdx\n  },\n  columns,\n  rowHeight,\n  scrollLeft\n}) {\n  if (idx < 0) {\n    return {\n      width: 0,\n      left: 0,\n      top: 0,\n      height: rowHeight,\n      zIndex: 1\n    };\n  }\n\n  const column = columns[idx];\n  const {\n    width\n  } = column;\n  const left = column.frozen ? column.left + scrollLeft : column.left;\n  const top = rowIdx * rowHeight;\n  const zIndex = column.frozen ? zFrozenCellMask : zCellMask;\n  return {\n    width,\n    left,\n    top,\n    height: rowHeight,\n    zIndex\n  };\n}\nexport function isSelectedCellEditable({\n  selectedPosition,\n  columns,\n  rows,\n  onCheckCellIsEditable\n}) {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({\n    row,\n    column,\n    ...selectedPosition\n  }) : true;\n  return isCellEditable && canEdit(column, row);\n}\nexport function getNextSelectedCellPosition({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  nextPosition\n}) {\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    const {\n      idx,\n      rowIdx\n    } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isLastRow = rowIdx === rowsCount - 1;\n\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isFirstRow = rowIdx === 0;\n\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\nexport function canExitGrid(event, {\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  selectedPosition: {\n    rowIdx,\n    idx\n  }\n}) {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    const shift = event.shiftKey === true;\n    return shift ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../src/utils/selectedCellUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CellNavigationMode } from '../common/enums';\nimport { canEdit } from './columnUtils';\nimport { CalculatedColumn, Position, Dimension } from '../common/types';\n\n// above unfrozen cells, below frozen cells\nconst zCellMask = 1;\n// above frozen cells, below header/filter/summary rows\nconst zFrozenCellMask = 2;\n\ninterface GetSelectedDimensionsOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowHeight: number;\n  scrollLeft: number;\n}\n\nexport function getSelectedDimensions<R, SR>({ selectedPosition: { idx, rowIdx }, columns, rowHeight, scrollLeft }: GetSelectedDimensionsOpts<R, SR>): Dimension {\n  if (idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: 1 };\n  }\n  const column = columns[idx];\n  const { width } = column;\n  const left = column.frozen ? column.left + scrollLeft : column.left;\n  const top = rowIdx * rowHeight;\n  const zIndex = column.frozen ? zFrozenCellMask : zCellMask;\n  return { width, left, top, height: rowHeight, zIndex };\n}\n\ninterface IsSelectedCellEditableOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly R[];\n  onCheckCellIsEditable?: (arg: { row: R; column: CalculatedColumn<R, SR> } & Position) => boolean;\n}\n\nexport function isSelectedCellEditable<R, SR>({ selectedPosition, columns, rows, onCheckCellIsEditable }: IsSelectedCellEditableOpts<R, SR>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({ row, column, ...selectedPosition }) : true;\n  return isCellEditable && canEdit<R, SR>(column, row);\n}\n\ninterface GetNextSelectedCellPositionOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport function getNextSelectedCellPosition<R, SR>({ cellNavigationMode, columns, rowsCount, nextPosition }: GetNextSelectedCellPositionOpts<R, SR>): Position {\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\ninterface CanExitGridOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  selectedPosition: Position;\n}\n\nexport function canExitGrid<R, SR>(event: React.KeyboardEvent, { cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx } }: CanExitGridOpts<R, SR>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    const shift = event.shiftKey === true;\n\n    return shift ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}